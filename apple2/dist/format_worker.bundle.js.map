{"version":3,"sources":["webpack://apple2js/./js/util.ts","webpack://apple2js/./js/base64.ts","webpack://apple2js/./js/formats/types.ts","webpack://apple2js/./js/formats/format_utils.ts","webpack://apple2js/./js/formats/do.ts","webpack://apple2js/./js/formats/nib.ts","webpack://apple2js/./js/formats/po.ts","webpack://apple2js/./js/formats/woz.ts","webpack://apple2js/./js/formats/create_disk.ts","webpack://apple2js/./js/formats/2mg.ts","webpack://apple2js/./js/formats/d13.ts","webpack://apple2js/./workers/format.worker.ts","webpack://apple2js/./js/types.ts"],"names":["bytify","ary","Uint8Array","args","console","log","apply","v","n","result","idx","numToString","num","String","fromCharCode","B64","base64_decode","data","o1","o2","o3","h1","h2","h3","h4","bits","i","ac","tmp_arr","indexOf","charAt","length","ENCODING_NIBBLE","NIBBLE_FORMATS","DO","PO","D13O","_trans53","_trans62","fourXfour","val","xx","yy","explodeSector16","volume","track","sector","gap","buf","push","checksum","concat","nibbles","idx2","idx6","val6","val2","last","explodeSector13","jdx","a5","a3","b5","b3","c5","c3","d5","d3","e5","e3","grabNibble","offset","nibble","waitForOne","createDiskFromDOS","options","name","side","rawData","readOnly","disk","format","encoding","tracks","t","physical_sector","dos_sector","off","slice","Error","createDiskFromNibble","createDiskFromProDOS","physical_track","prodos_sector","stringFromBytes","start","end","buffer","byteOffset","InfoChunk","sides","bootSector","bitTiming","compatibleHardware","requiredRAM","largestTrack","this","version","getUint8","diskType","writeProtected","synchronized","cleaned","creator","getUint16","TMapChunk","trackMap","TrksChunk","TrksChunk1","super","rawTracks","trackNo","byteLength","rawTrack","trackData","trackBitCount","DataView","byteIndex","bitIndex","TrksChunk2","trks","startBlock","blockCount","bitCount","getUint32","trk","MetaChunk","parts","split","values","reduce","acc","part","subParts","createDisk","fmt","bytes","prefix","signature","getInt32","flags","read2MGHeader","createDiskFrom2MG","disk_sector","dv","wozVersion","dvOffset","chunks","readChunk","type","size","WOZ_HEADER_START","readHeader","chunk","info","tmap","meta","createDiskFromWoz","addEventListener","message","drive","payload","jsonDisk","includes","s","createDiskFromJsonDisk","json","JSON","parse","_s","d","jsonDecode","response","self","postMessage"],"mappings":"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","file":"format_worker.bundle.js","sourcesContent":["import { byte, memory, word } from './types';\n\n/*eslint no-console: 0*/\n\nconst hex_digits = '0123456789ABCDEF';\nconst bin_digits = '01';\n\n/** Returns a random byte. */\nexport function garbage(): byte {\n    return (Math.random() * 0x100) & 0xff;\n}\n\nexport const testables = {\n    garbage\n};\n\n/**\n * Returns an array or Uint8Array of `size` bytes filled as if the computer\n * was just powered on.\n */\nexport function allocMem(size: number) {\n    const result = new Uint8Array(size);\n\n    for (let idx = 0; idx < size; idx++) {\n        result[idx] = (idx & 0x02) ? 0x00 : 0xff;\n    }\n    // Borrowed from AppleWin (https://github.com/AppleWin/AppleWin)\n    for (let idx = 0; idx < size; idx += 0x200) {\n        result[idx + 0x28] = garbage();\n        result[idx + 0x29] = garbage();\n        result[idx + 0x68] = garbage();\n        result[idx + 0x69] = garbage();\n    }\n    return result;\n}\n\n/** Returns an array or Uint8Array of 256 * `pages` bytes. */\nexport function allocMemPages(pages: number): memory {\n    return allocMem(pages << 8);\n}\n\n/** Returns a new Uint8Array for the input array. */\nexport function bytify(ary: number[]): memory {\n    return new Uint8Array(ary);\n}\n\n/** Writes to the console. */\nexport function debug(...args: any[]): void {\n    console.log.apply(console, args);\n}\n\n/**\n * Returns a string of hex digits (all caps).\n * @param v the value to encode\n * @param n the number of nibbles. If `n` is missing, it is guessed from the value\n *     of `v`. If `v` < 256, it is assumed to be 2 nibbles, otherwise 4.\n */\nexport function toHex(v: byte | word | number, n?: number) {\n    if (!n) {\n        n = v < 256 ? 2 : 4;\n    }\n    let result = '';\n    for (let idx = 0; idx < n; idx++) {\n        result = hex_digits[v & 0x0f] + result;\n        v >>= 4;\n    }\n    return result;\n}\n\n/**\n * Returns a string of 8 binary digits.\n * @param v the value to encode\n */\nexport function toBinary(v: byte) {\n    let result = '';\n    for (let idx = 0; idx < 8; idx++) {\n        result = bin_digits[v & 0x01] + result;\n        v >>= 1;\n    }\n    return result;\n}\n\n/** Packs a 32-bit integer into a string in little-endian order. */\nexport function numToString(num: number) {\n    let result = '';\n    for (let idx = 0; idx < 4; idx++) {\n        result += String.fromCharCode(num & 0xff);\n        num >>= 8;\n    }\n    return result;\n}\n","import { memory } from './types';\n\nconst B64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\n/** Encode an array of bytes in base64. */\nexport function base64_encode(data: null | undefined): undefined;\nexport function base64_encode(data: memory): string;\nexport function base64_encode(data: memory | null | undefined): string | undefined {\n    // Twacked by Will Scullin to handle arrays of 'bytes'\n\n    // http://kevin.vanzonneveld.net\n    // +   original by: Tyler Akins (http://rumkin.com)\n    // +   improved by: Bayron Guevara\n    // +   improved by: Thunder.m\n    // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n    // +   bugfixed by: Pellentesque Malesuada\n    // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n    // -    depends on: utf8_encode\n    // *     example 1: base64_encode('Kevin van Zonneveld');\n    // *     returns 1: 'S2V2aW4gdmFuIFpvbm5ldmVsZA=='\n\n    // mozilla has this native\n    // - but breaks in 2.0.0.12!\n    //if (typeof this.window['atob'] == 'function') {\n    //    return atob(data);\n    //}\n\n\n    let o1, o2, o3, h1, h2, h3, h4, bits, i = 0, ac = 0, enc='';\n    const tmp_arr = [];\n\n    if (!data) {\n        return undefined;\n    }\n\n    do { // pack three octets into four hexets\n        o1 = data[i++];\n        o2 = data[i++];\n        o3 = data[i++];\n\n        bits = o1<<16 | o2<<8 | o3;\n\n        h1 = bits>>18 & 0x3f;\n        h2 = bits>>12 & 0x3f;\n        h3 = bits>>6 & 0x3f;\n        h4 = bits & 0x3f;\n\n        // use hexets to index into b64, and append result to encoded string\n        tmp_arr[ac++] = B64.charAt(h1) + B64.charAt(h2) + B64.charAt(h3) + B64.charAt(h4);\n    } while (i < data.length);\n\n    enc = tmp_arr.join('');\n\n    switch (data.length % 3) {\n        case 1:\n            enc = enc.slice(0, -2) + '==';\n            break;\n        case 2:\n            enc = enc.slice(0, -1) + '=';\n            break;\n    }\n\n    return enc;\n}\n\n/** Returns undefined if the input is null or undefined. */\nexport function base64_decode(data: null | undefined): undefined;\n/** Returns an array of bytes from the given base64-encoded string. */\nexport function base64_decode(data: string): memory;\n/** Returns an array of bytes from the given base64-encoded string. */\nexport function base64_decode(data: string | null | undefined): memory | undefined {\n    // Twacked by Will Scullin to handle arrays of 'bytes'\n\n    // http://kevin.vanzonneveld.net\n    // +   original by: Tyler Akins (http://rumkin.com)\n    // +   improved by: Thunder.m\n    // +      input by: Aman Gupta\n    // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n    // +   bugfixed by: Onno Marsman\n    // +   bugfixed by: Pellentesque Malesuada\n    // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n    // +      input by: Brett Zamir (http://brett-zamir.me)\n    // +   bugfixed by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n    // -    depends on: utf8_decode\n    // *     example 1: base64_decode('S2V2aW4gdmFuIFpvbm5ldmVsZA==');\n    // *     returns 1: 'Kevin van Zonneveld'\n\n    // mozilla has this native\n    // - but breaks in 2.0.0.12!\n    //if (typeof this.window['btoa'] == 'function') {\n    //    return btoa(data);\n    //}\n\n    let o1, o2, o3, h1, h2, h3, h4, bits, i = 0, ac = 0;\n    const tmp_arr = [];\n\n    if (!data) {\n        return undefined;\n    }\n\n    do {  // unpack four hexets into three octets using index points in B64\n        h1 = B64.indexOf(data.charAt(i++));\n        h2 = B64.indexOf(data.charAt(i++));\n        h3 = B64.indexOf(data.charAt(i++));\n        h4 = B64.indexOf(data.charAt(i++));\n\n        bits = h1<<18 | h2<<12 | h3<<6 | h4;\n\n        o1 = bits>>16 & 0xff;\n        o2 = bits>>8 & 0xff;\n        o3 = bits & 0xff;\n\n        tmp_arr[ac++] = o1;\n        if (h3 != 64) {\n            tmp_arr[ac++] = o2;\n        }\n        if (h4 != 64) {\n            tmp_arr[ac++] = o3;\n        }\n    } while (i < data.length);\n\n    return new Uint8Array(tmp_arr);\n}\n\nconst DATA_URL_PREFIX = 'data:application/octet-stream;base64,';\n\nexport function base64_json_parse(json: string) {\n    const reviver = (_key: string, value: any) => {\n        if (typeof value ==='string' && value.startsWith(DATA_URL_PREFIX)) {\n            return base64_decode(value.slice(DATA_URL_PREFIX.length));\n        }\n        return value;\n    };\n\n    return JSON.parse(json, reviver);\n}\n\nexport function base64_json_stringify(json: any) {\n    const replacer = (_key: string, value: any) => {\n        if (value instanceof Uint8Array) {\n            return DATA_URL_PREFIX + base64_encode(value);\n        }\n        return value;\n    };\n\n    return JSON.stringify(json, replacer);\n}\n","import type { byte, memory, MemberOf } from '../types';\nimport type { GamepadConfiguration } from '../ui/types';\n\nexport const DRIVE_NUMBERS = [1, 2] as const;\nexport type DriveNumber = MemberOf<typeof DRIVE_NUMBERS>;\n\n/**\n * Arguments for the disk format processors.\n */\n\nexport interface DiskOptions {\n    name: string\n    side?: string\n    volume: byte\n    readOnly: boolean\n    data?: memory[][]\n    rawData?: ArrayBuffer\n    blockVolume?: boolean\n}\n\n/**\n * Return value from disk format processors. Describes raw disk\n * data which the DiskII card can process.\n */\n\nexport interface Disk {\n    name: string\n    side?: string\n    readOnly: boolean\n}\n\nexport const ENCODING_NIBBLE = 'nibble';\nexport const ENCODING_BITSTREAM = 'bitstream';\nexport const ENCODING_BLOCK = 'block';\n\nexport interface FloppyDisk extends Disk {\n    tracks: memory[]\n}\n\nexport interface NibbleDisk extends FloppyDisk {\n    encoding: typeof ENCODING_NIBBLE\n    format: DiskFormat\n    volume: byte\n}\n\nexport interface WozDisk extends FloppyDisk {\n    encoding: typeof ENCODING_BITSTREAM\n    trackMap: number[]\n    rawTracks: Uint8Array[]\n}\n\nexport interface BlockDisk extends Disk {\n    encoding: typeof ENCODING_BLOCK\n    blocks: Uint8Array[]\n}\n\n/**\n * File types supported by the disk format processors and\n * block devices.\n */\n\nexport const NIBBLE_FORMATS = [\n    '2mg',\n    'd13',\n    'do',\n    'dsk',\n    'po',\n    'nib',\n    'woz'\n] as const;\n\nexport const BLOCK_FORMATS = [\n    '2mg',\n    'hdv',\n    'po',\n] as const;\n\nexport const DISK_FORMATS = [...NIBBLE_FORMATS, ...BLOCK_FORMATS ] as const;\n\nexport type NibbleFormat = MemberOf<typeof NIBBLE_FORMATS>;\nexport type BlockFormat = MemberOf<typeof BLOCK_FORMATS>;\nexport type DiskFormat = MemberOf<typeof DISK_FORMATS>;\n\n/**\n * Base format for JSON defined disks\n */\n\nexport class JSONDiskBase {\n    type: DiskFormat;\n    name: string;\n    disk?: string;\n    category?: string;\n    volume?: byte;\n    readOnly?: boolean;\n    gamepad?: GamepadConfiguration;\n}\n\n/**\n * JSON Disk format with base64 encoded tracks with sectors\n */\n\nexport interface Base64JSONDisk extends JSONDiskBase {\n    type: Exclude<DiskFormat, 'nib'>\n    encoding: 'base64'\n    data: string[][]\n}\n\n/**\n * JSON Disk format with base64 encoded nibblized tracks\n */\n\nexport interface Base64JSONNibbleDisk extends JSONDiskBase {\n    type: 'nib'\n    encoding: 'base64'\n    data: string[]\n}\n\n/**\n * JSON Disk format with byte array tracks\n */\n\nexport interface BinaryJSONDisk extends JSONDiskBase {\n    type: DiskFormat\n    encoding: 'binary'\n    data: memory[][]\n}\n\n/**\n * General JSON Disk format\n */\n\nexport type JSONDisk = Base64JSONDisk | Base64JSONNibbleDisk | BinaryJSONDisk;\n\n/**\n * Process Disk message payloads for worker\n */\n\nexport const PROCESS_BINARY = 'PROCESS_BINARY';\nexport const PROCESS_JSON_DISK = 'PROCESS_JSON_DISK';\nexport const PROCESS_JSON = 'PROCESS_JSON';\n\n/** Binary disk file message */\nexport interface ProcessBinaryMessage {\n    type: typeof PROCESS_BINARY\n    payload: {\n        drive: DriveNumber\n        fmt: NibbleFormat\n        options: DiskOptions\n    }\n}\n\n/** Processed JSON file message (used for localStorage) */\nexport interface ProcessJsonDiskMessage {\n    type: typeof PROCESS_JSON_DISK\n    payload: {\n        drive: DriveNumber\n        jsonDisk: JSONDisk\n    }\n}\n\n/** Raw JSON file message */\nexport interface ProcessJsonMessage {\n    type: typeof PROCESS_JSON\n    payload: {\n        drive: DriveNumber\n        json: string\n    }\n}\n\nexport type FormatWorkerMessage =\n    ProcessBinaryMessage |\n    ProcessJsonDiskMessage |\n    ProcessJsonMessage;\n\n/**\n * Format work result message type\n */\n\nexport const DISK_PROCESSED = 'DISK_PROCESSED';\n\nexport interface DiskProcessedResponse {\n    type: typeof DISK_PROCESSED\n    payload: {\n        drive: DriveNumber\n        disk: Disk | null\n    }\n}\n\nexport type FormatWorkerResponse =\n    DiskProcessedResponse\n\n/**\n * Block device common interface\n */\nexport interface MassStorage {\n    setBinary(drive: number, name: string, ext: BlockFormat, data: ArrayBuffer): boolean\n}\n","import { bit, byte, memory } from '../types';\nimport { base64_decode, base64_encode } from '../base64';\nimport { bytify, debug, toHex } from '../util';\nimport { NibbleDisk, ENCODING_NIBBLE } from './types';\n\n/**\n * DOS 3.3 Physical sector order (index is physical sector, value is DOS sector).\n */\nexport const DO = [\n    0x0, 0x7, 0xE, 0x6, 0xD, 0x5, 0xC, 0x4,\n    0xB, 0x3, 0xA, 0x2, 0x9, 0x1, 0x8, 0xF\n] as const;\n\n/**\n * DOS 3.3 Logical sector order (index is DOS sector, value is physical sector).\n */\nexport const _DO = [\n    0x0, 0xD, 0xB, 0x9, 0x7, 0x5, 0x3, 0x1,\n    0xE, 0xC, 0xA, 0x8, 0x6, 0x4, 0x2, 0xF\n] as const;\n\n/**\n * ProDOS Physical sector order (index is physical sector, value is ProDOS sector).\n */\nexport const PO = [\n    0x0, 0x8, 0x1, 0x9, 0x2, 0xa, 0x3, 0xb,\n    0x4, 0xc, 0x5, 0xd, 0x6, 0xe, 0x7, 0xf\n] as const;\n\n/**\n * ProDOS Logical sector order (index is ProDOS sector, value is physical sector).\n */\nexport const _PO = [\n    0x0, 0x2, 0x4, 0x6, 0x8, 0xa, 0xc, 0xe,\n    0x1, 0x3, 0x5, 0x7, 0x9, 0xb, 0xd, 0xf\n] as const;\n\n/**\n * DOS 13-sector disk physical sector order (index is disk sector, value is\n * physical sector).\n */\nexport const D13O = [\n    0x0, 0xa, 0x7, 0x4, 0x1, 0xb, 0x8, 0x5, 0x2, 0xc, 0x9, 0x6, 0x3\n] as const;\n\nexport const _D13O = [\n    0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc\n] as const;\n\nconst _trans53 = [\n    0xab, 0xad, 0xae, 0xaf, 0xb5, 0xb6, 0xb7, 0xba,\n    0xbb, 0xbd, 0xbe, 0xbf, 0xd6, 0xd7, 0xda, 0xdb,\n    0xdd, 0xde, 0xdf, 0xea, 0xeb, 0xed, 0xee, 0xef,\n    0xf5, 0xf6, 0xf7, 0xfa, 0xfb, 0xfd, 0xfe, 0xff\n] as const;\n\nconst _trans62 = [\n    0x96, 0x97, 0x9a, 0x9b, 0x9d, 0x9e, 0x9f, 0xa6,\n    0xa7, 0xab, 0xac, 0xad, 0xae, 0xaf, 0xb2, 0xb3,\n    0xb4, 0xb5, 0xb6, 0xb7, 0xb9, 0xba, 0xbb, 0xbc,\n    0xbd, 0xbe, 0xbf, 0xcb, 0xcd, 0xce, 0xcf, 0xd3,\n    0xd6, 0xd7, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde,\n    0xdf, 0xe5, 0xe6, 0xe7, 0xe9, 0xea, 0xeb, 0xec,\n    0xed, 0xee, 0xef, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6,\n    0xf7, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff\n] as const;\n\nexport const detrans62 = [\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,\n    0x00, 0x00, 0x02, 0x03, 0x00, 0x04, 0x05, 0x06,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x08,\n    0x00, 0x00, 0x00, 0x09, 0x0A, 0x0B, 0x0C, 0x0D,\n    0x00, 0x00, 0x0E, 0x0F, 0x10, 0x11, 0x12, 0x13,\n    0x00, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x1B, 0x00, 0x1C, 0x1D, 0x1E,\n    0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x20, 0x21,\n    0x00, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0x2A, 0x2B,\n    0x00, 0x2C, 0x2D, 0x2E, 0x2F, 0x30, 0x31, 0x32,\n    0x00, 0x00, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,\n    0x00, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F\n] as const;\n\n/**\n * Converts a byte into its 4x4 encoded representation\n *\n * @param val byte to encode.\n * @returns A two byte array of representing the 4x4 encoding.\n */\nexport function fourXfour(val: byte): [xx: byte, yy: byte] {\n    let xx = val & 0xaa;\n    let yy = val & 0x55;\n\n    xx >>= 1;\n    xx |= 0xaa;\n    yy |= 0xaa;\n\n    return [xx, yy];\n}\n\n/**\n * Converts 2 4x4 encoded bytes into a byte value\n *\n * @param xx First encoded byte.\n * @param yy Second encoded byte.\n * @returns The decoded value.\n */\nexport function defourXfour(xx: byte, yy: byte): byte {\n    return ((xx << 1) | 0x01) & yy;\n}\n\n/**\n * Converts a raw sector into a nibblized representation to be combined into a\n * nibblized 16 sector track.\n *\n * @param volume volume number\n * @param track track number\n * @param sector sector number\n * @param data sector data\n * @returns a nibblized representation of the sector data\n */\nexport function explodeSector16(volume: byte, track: byte, sector: byte, data: memory): byte[] {\n    let buf = [];\n    let gap;\n\n    /*\n     * Gap 1/3 (40/0x28 bytes)\n     */\n\n    if (sector === 0) // Gap 1\n        gap = 0x80;\n    else { // Gap 3\n        gap = track === 0 ? 0x28 : 0x26;\n    }\n\n    for (let idx = 0; idx < gap; idx++) {\n        buf.push(0xff);\n    }\n\n    /*\n     * Address Field\n     */\n\n    const checksum = volume ^ track ^ sector;\n    buf = buf.concat([0xd5, 0xaa, 0x96]); // Address Prolog D5 AA 96\n    buf = buf.concat(fourXfour(volume));\n    buf = buf.concat(fourXfour(track));\n    buf = buf.concat(fourXfour(sector));\n    buf = buf.concat(fourXfour(checksum));\n    buf = buf.concat([0xde, 0xaa, 0xeb]); // Epilog DE AA EB\n\n    /*\n     * Gap 2 (5 bytes)\n     */\n\n    for (let idx = 0; idx < 0x05; idx++) {\n        buf.push(0xff);\n    }\n\n    /*\n     * Data Field\n     */\n\n    buf = buf.concat([0xd5, 0xaa, 0xad]); // Data Prolog D5 AA AD\n\n    const nibbles: byte[] = [];\n    const ptr2 = 0;\n    const ptr6 = 0x56;\n\n    for (let idx = 0; idx < 0x156; idx++) {\n        nibbles[idx] = 0;\n    }\n\n    let idx2 = 0x55;\n    for (let idx6 = 0x101; idx6 >= 0; idx6--) {\n        let val6 = data[idx6 % 0x100];\n        let val2: byte = nibbles[ptr2 + idx2];\n\n        val2 = (val2 << 1) | (val6 & 1);\n        val6 >>= 1;\n        val2 = (val2 << 1) | (val6 & 1);\n        val6 >>= 1;\n\n        nibbles[ptr6 + idx6] = val6;\n        nibbles[ptr2 + idx2] = val2;\n\n        if (--idx2 < 0)\n            idx2 = 0x55;\n    }\n\n    let last = 0;\n    for (let idx = 0; idx < 0x156; idx++) {\n        const val = nibbles[idx];\n        buf.push(_trans62[last ^ val]);\n        last = val;\n    }\n    buf.push(_trans62[last]);\n\n    buf = buf.concat([0xde, 0xaa, 0xeb]); // Epilog DE AA EB\n\n    /*\n     * Gap 3\n     */\n\n    buf.push(0xff);\n\n    return buf;\n}\n\n/**\n * Converts a raw sector into a nibblized representation to be combined into\n * a nibblized 13 sector track.\n *\n * @param volume volume number\n * @param track track number\n * @param sector sector number\n * @param data sector data\n * @returns a nibblized representation of the sector data\n */\nexport function explodeSector13(volume: byte, track: byte, sector: byte, data: memory): byte[] {\n    let buf = [];\n    let gap;\n\n    /*\n     * Gap 1/3 (40/0x28 bytes)\n     */\n\n    if (sector === 0) // Gap 1\n        gap = 0x80;\n    else { // Gap 3\n        gap = track === 0 ? 0x28 : 0x26;\n    }\n\n    for (let idx = 0; idx < gap; idx++) {\n        buf.push(0xff);\n    }\n\n    /*\n     * Address Field\n     */\n\n    const checksum = volume ^ track ^ sector;\n    buf = buf.concat([0xd5, 0xaa, 0xb5]); // Address Prolog D5 AA B5\n    buf = buf.concat(fourXfour(volume));\n    buf = buf.concat(fourXfour(track));\n    buf = buf.concat(fourXfour(sector));\n    buf = buf.concat(fourXfour(checksum));\n    buf = buf.concat([0xde, 0xaa, 0xeb]); // Epilog DE AA EB\n\n    /*\n     * Gap 2 (5 bytes)\n     */\n\n    for (let idx = 0; idx < 0x05; idx++) {\n        buf.push(0xff);\n    }\n\n    /*\n     * Data Field\n     */\n\n    buf = buf.concat([0xd5, 0xaa, 0xad]); // Data Prolog D5 AA AD\n\n    const nibbles = [];\n\n    let jdx = 0;\n    for (let idx = 0x32; idx >= 0; idx--) {\n        const a5 = data[jdx] >> 3;\n        const a3 = data[jdx] & 0x07;\n        jdx++;\n        const b5 = data[jdx] >> 3;\n        const b3 = data[jdx] & 0x07;\n        jdx++;\n        const c5 = data[jdx] >> 3;\n        const c3 = data[jdx] & 0x07;\n        jdx++;\n        const d5 = data[jdx] >> 3;\n        const d3 = data[jdx] & 0x07;\n        jdx++;\n        const e5 = data[jdx] >> 3;\n        const e3 = data[jdx] & 0x07;\n        jdx++;\n        nibbles[idx + 0x00] = a5;\n        nibbles[idx + 0x33] = b5;\n        nibbles[idx + 0x66] = c5;\n        nibbles[idx + 0x99] = d5;\n        nibbles[idx + 0xcc] = e5;\n        nibbles[idx + 0x100] = a3 << 2 | (d3 & 0x4) >> 1 | (e3 & 0x4) >> 2;\n        nibbles[idx + 0x133] = b3 << 2 | (d3 & 0x2) | (e3 & 0x2) >> 1;\n        nibbles[idx + 0x166] = c3 << 2 | (d3 & 0x1) << 1 | (e3 & 0x1);\n    }\n    nibbles[0xff] = data[jdx] >> 3;\n    nibbles[0x199] = data[jdx] & 0x07;\n\n    let last = 0;\n    for (let idx = 0x199; idx >= 0x100; idx--) {\n        const val = nibbles[idx];\n        buf.push(_trans53[last ^ val]);\n        last = val;\n    }\n    for (let idx = 0x0; idx < 0x100; idx++) {\n        const val = nibbles[idx];\n        buf.push(_trans53[last ^ val]);\n        last = val;\n    }\n    buf.push(_trans53[last]);\n\n    buf = buf.concat([0xde, 0xaa, 0xeb]); // Epilog DE AA EB\n\n    /*\n     * Gap 3\n     */\n\n    buf.push(0xff);\n\n    return buf;\n}\n\n/**\n * Reads a sector of data from a nibblized disk\n *\n * TODO(flan): Does not work on WOZ disks\n *\n * @param disk Nibble disk\n * @param track track number to read\n * @param sector sector number to read\n * @returns An array of sector data bytes.\n */\nexport function readSector(disk: NibbleDisk, track: byte, sector: byte): memory {\n    const _sector = disk.format == 'po' ? _PO[sector] : _DO[sector];\n    let val, state = 0;\n    let idx = 0;\n    let retry = 0;\n    const cur = disk.tracks[track];\n\n    function _readNext() {\n        const result = cur[idx++];\n        if (idx >= cur.length) {\n            idx = 0;\n            retry++;\n        }\n        return result;\n    }\n    function _skipBytes(count: number) {\n        idx += count;\n        if (idx >= cur.length) {\n            idx %= cur.length;\n            retry++;\n        }\n    }\n    let t = 0, s = 0, v = 0, checkSum;\n    const data = new Uint8Array(256);\n    while (retry < 4) {\n        switch (state) {\n            case 0:\n                val = _readNext();\n                state = (val === 0xd5) ? 1 : 0;\n                break;\n            case 1:\n                val = _readNext();\n                state = (val === 0xaa) ? 2 : 0;\n                break;\n            case 2:\n                val = _readNext();\n                state = (val === 0x96) ? 3 : (val === 0xad ? 4 : 0);\n                break;\n            case 3: // Address\n                v = defourXfour(_readNext(), _readNext()); // Volume\n                t = defourXfour(_readNext(), _readNext());\n                s = defourXfour(_readNext(), _readNext());\n                checkSum = defourXfour(_readNext(), _readNext());\n                if (checkSum != (v ^ t ^ s)) {\n                    debug('Invalid header checksum:', toHex(v), toHex(t), toHex(s), toHex(checkSum));\n                }\n                _skipBytes(3); // Skip footer\n                state = 0;\n                break;\n            case 4: // Data\n                if (s === _sector && t === track) {\n                    const data2 = [];\n                    let last = 0;\n                    for (let jdx = 0x55; jdx >= 0; jdx--) {\n                        val = detrans62[_readNext() - 0x80] ^ last;\n                        data2[jdx] = val;\n                        last = val;\n                    }\n                    for (let jdx = 0; jdx < 0x100; jdx++) {\n                        val = detrans62[_readNext() - 0x80] ^ last;\n                        data[jdx] = val;\n                        last = val;\n                    }\n                    checkSum = detrans62[_readNext() - 0x80] ^ last;\n                    if (checkSum) {\n                        debug('Invalid data checksum:', toHex(v), toHex(t), toHex(s), toHex(checkSum));\n                    }\n                    for (let kdx = 0, jdx = 0x55; kdx < 0x100; kdx++) {\n                        data[kdx] <<= 1;\n                        if ((data2[jdx] & 0x01) !== 0) {\n                            data[kdx] |= 0x01;\n                        }\n                        data2[jdx] >>= 1;\n\n                        data[kdx] <<= 1;\n                        if ((data2[jdx] & 0x01) !== 0) {\n                            data[kdx] |= 0x01;\n                        }\n                        data2[jdx] >>= 1;\n\n                        if (--jdx < 0) jdx = 0x55;\n                    }\n                    return data;\n                }\n                else\n                    _skipBytes(0x159); // Skip data, checksum and footer\n                state = 0;\n                break;\n            default:\n                break;\n        }\n    }\n    return new Uint8Array();\n}\n\n/**\n * Convert a nibblized disk into a JSON string for storage.\n *\n * @param disk Nibblized disk\n * @param pretty Whether to format the output string\n * @returns A JSON string representing the disk\n */\nexport function jsonEncode(disk: NibbleDisk, pretty: boolean): string {\n    // For 'nib', tracks are encoded as strings. For all other formats,\n    // tracks are arrays of sectors which are encoded as strings.\n    const data: string[] | string[][] = [];\n    let format = 'dsk';\n    for (let t = 0; t < disk.tracks.length; t++) {\n        data[t] = [];\n        if (disk.format === 'nib') {\n            format = 'nib';\n            data[t] = base64_encode(disk.tracks[t]);\n        } else {\n            for (let s = 0; s < 0x10; s++) {\n                (data[t] as string[])[s] = base64_encode(readSector(disk, t, s));\n            }\n        }\n    }\n    return JSON.stringify({\n        'type': format,\n        'encoding': 'base64',\n        'volume': disk.volume,\n        'data': data,\n        'readOnly': disk.readOnly,\n    }, undefined, pretty ? '    ' : undefined);\n}\n\n/**\n * Convert a JSON string into a nibblized disk.\n *\n * @param data JSON string representing a disk image, created by [jsonEncode].\n * @returns A nibblized disk\n */\n\nexport function jsonDecode(data: string): NibbleDisk {\n    const tracks: memory[] = [];\n    const json = JSON.parse(data);\n    const v = json.volume;\n    const readOnly = json.readOnly;\n    for (let t = 0; t < json.data.length; t++) {\n        let track: byte[] = [];\n        for (let s = 0; s < json.data[t].length; s++) {\n            const _s = json.type == 'po' ? PO[s] : DO[s];\n            const sector: string = json.data[t][_s];\n            const d = base64_decode(sector);\n            track = track.concat(explodeSector16(v, t, s, d));\n        }\n        tracks[t] = bytify(track);\n    }\n    const disk: NibbleDisk = {\n        volume: v,\n        format: json.type,\n        encoding: ENCODING_NIBBLE,\n        name: json.name,\n        tracks,\n        readOnly,\n    };\n\n    return disk;\n}\n\n/**\n * Debugging method that displays the logical sector ordering of a nibblized disk\n *\n * @param disk\n */\n\nexport function analyseDisk(disk: NibbleDisk) {\n    for (let track = 0; track < 35; track++) {\n        let outStr = `${toHex(track)}: `;\n        let val, state = 0;\n        let idx = 0;\n        const cur = disk.tracks[track];\n\n        const _readNext = () => {\n            const result = cur[idx++];\n            return result;\n        };\n\n        const _skipBytes = (count: number) => {\n            idx += count;\n        };\n\n        let t = 0, s = 0, v = 0, checkSum;\n        while (idx < cur.length) {\n            switch (state) {\n                case 0:\n                    val = _readNext();\n                    state = (val === 0xd5) ? 1 : 0;\n                    break;\n                case 1:\n                    val = _readNext();\n                    state = (val === 0xaa) ? 2 : 0;\n                    break;\n                case 2:\n                    val = _readNext();\n                    state = (val === 0x96) ? 3 : (val === 0xad ? 4 : 0);\n                    break;\n                case 3: // Address\n                    v = defourXfour(_readNext(), _readNext()); // Volume\n                    t = defourXfour(_readNext(), _readNext());\n                    s = defourXfour(_readNext(), _readNext());\n                    checkSum = defourXfour(_readNext(), _readNext());\n                    if (checkSum != (v ^ t ^ s)) {\n                        debug('Invalid header checksum:', toHex(v), toHex(t), toHex(s), toHex(checkSum));\n                    } else {\n                        outStr += toHex(s, 1);\n                    }\n                    _skipBytes(3); // Skip footer\n                    state = 0;\n                    break;\n                case 4: // Valid header\n                    _skipBytes(0x159); // Skip data, checksum and footer\n                    state = 0;\n                    break;\n                default:\n                    break;\n            }\n        }\n        debug(outStr);\n    }\n}\n\n/**\n * Debugging utility to convert a bitstream into a nibble. Does not wrap.\n *\n * @param bits Bitstream containing nibbles\n * @param offset Offset into bitstream to start nibblizing\n * @returns nibble, the next nibble in the bitstream,\n *      and offset, the end of that nibble in the bitstream\n */\n\nexport function grabNibble(bits: bit[], offset: number) {\n    let nibble = 0;\n    let waitForOne = true;\n\n    while (offset < bits.length) {\n        const bit = bits[offset];\n        if (bit) {\n            nibble = (nibble << 1) | 0x01;\n            waitForOne = false;\n        } else {\n            if (!waitForOne) {\n                nibble = nibble << 1;\n            }\n        }\n        if (nibble & 0x80) {\n            // nibble complete return it\n            break;\n        }\n        offset += 1;\n    }\n\n    return {\n        nibble: nibble,\n        offset: offset\n    };\n}\n","import { explodeSector16, DO } from './format_utils';\nimport { bytify } from '../util';\nimport { byte } from '../types';\nimport { NibbleDisk, DiskOptions, ENCODING_NIBBLE } from './types';\n\n/**\n * Returns a `Disk` object from DOS-ordered image data.\n * @param options the disk image and options\n * @returns A nibblized disk\n */\nexport default function createDiskFromDOS(options: DiskOptions): NibbleDisk {\n    const { data, name, side, rawData, volume, readOnly } = options;\n    const disk: NibbleDisk = {\n        format: 'dsk',\n        encoding: ENCODING_NIBBLE,\n        name,\n        side,\n        volume,\n        readOnly,\n        tracks: [],\n    };\n\n    for (let t = 0; t < 35; t++) {\n        let track: byte[] = [];\n        for (let physical_sector = 0; physical_sector < 16; physical_sector++) {\n            const dos_sector = DO[physical_sector];\n            let sector: Uint8Array;\n            if (rawData) {\n                const off = (16 * t + dos_sector) * 256;\n                sector = new Uint8Array(rawData.slice(off, off + 256));\n            } else if (data) {\n                sector = new Uint8Array(data[t][dos_sector]);\n            } else {\n                throw new Error('Requires data or rawData');\n            }\n            track = track.concat(\n                explodeSector16(volume, t, physical_sector, sector)\n            );\n        }\n        disk.tracks[t] = bytify(track);\n    }\n    return disk;\n}\n","import { NibbleDisk, DiskOptions, ENCODING_NIBBLE } from './types';\nimport { memory } from '../types';\n\n/**\n * Returns a `Disk` object from raw nibble image data.\n * @param options the disk image and options\n * @returns A nibblized disk\n */\nexport default function createDiskFromNibble(options: DiskOptions): NibbleDisk {\n    const { data, name, side, rawData, volume, readOnly } = options;\n    const disk: NibbleDisk = {\n        format: 'nib',\n        encoding: ENCODING_NIBBLE,\n        name,\n        side,\n        volume: volume || 254,\n        readOnly: readOnly || false,\n        tracks: []\n    };\n\n    for (let t = 0; t < 35; t++) {\n        let track: memory;\n        if (rawData) {\n            const off = t * 0x1a00;\n            track = new Uint8Array(rawData.slice(off, off + 0x1a00));\n        } else if (data) {\n            track = data[t][0];\n        } else {\n            throw new Error('Requires data or rawData');\n        }\n        disk.tracks[t] = track;\n    }\n\n    return disk;\n}\n","import { explodeSector16, PO } from './format_utils';\nimport { bytify } from '../util';\nimport type { byte } from '../types';\nimport { NibbleDisk, DiskOptions, ENCODING_NIBBLE } from './types';\n\n/**\n * Returns a `Disk` object from ProDOS-ordered image data.\n * @param options the disk image and options\n * @returns A nibblized disk\n */\nexport default function createDiskFromProDOS(options: DiskOptions) {\n    const { data, name, side, rawData, volume, readOnly } = options;\n    const disk: NibbleDisk = {\n        format: 'nib',\n        encoding: ENCODING_NIBBLE,\n        name,\n        side,\n        volume: volume || 254,\n        tracks: [],\n        readOnly: readOnly || false,\n    };\n\n    for (let physical_track = 0; physical_track < 35; physical_track++) {\n        let track: byte[] = [];\n        for (let physical_sector = 0; physical_sector < 16; physical_sector++) {\n            const prodos_sector = PO[physical_sector];\n            let sector;\n            if (rawData) {\n                const off = (16 * physical_track + prodos_sector) * 256;\n                sector = new Uint8Array(rawData.slice(off, off + 256));\n            } else if (data) {\n                sector = data[physical_track][prodos_sector];\n            } else {\n                throw new Error('Requires data or rawData');\n            }\n            track = track.concat(\n                explodeSector16(volume, physical_track, physical_sector, sector)\n            );\n        }\n        disk.tracks[physical_track] = bytify(track);\n    }\n\n    return disk;\n}\n","import { debug, toHex } from '../util';\nimport { bit, byte, word } from '../types';\nimport { grabNibble } from './format_utils';\nimport { DiskOptions, ENCODING_BITSTREAM, WozDisk } from './types';\n\nconst WOZ_HEADER_START = 0;\nconst WOZ_HEADER_SIZE = 12;\n\nconst WOZ1_SIGNATURE = 0x315A4F57;\nconst WOZ2_SIGNATURE = 0x325A4F57;\nconst WOZ_INTEGRITY_CHECK = 0x0a0d0aff;\n\n/**\n * Converts a range of bytes from a DataView into an ASCII string\n *\n * @param data DataView containing string\n * @param start start index of string\n * @param end end index of string\n * @returns ASCII string\n */\nfunction stringFromBytes(data: DataView, start: number, end: number): string {\n    return String.fromCharCode.apply(\n        null,\n        new Uint8Array(data.buffer.slice(data.byteOffset + start, data.byteOffset + end))\n    );\n}\n\nexport class InfoChunk {\n    version: byte;\n\n    // Version 1\n    diskType: byte;\n    writeProtected: byte;\n    synchronized: byte;\n    cleaned: byte;\n    creator: string;\n\n    // Version 2\n    sides: byte = 0;\n    bootSector: byte = 0;\n    bitTiming: byte = 0;\n    compatibleHardware: word = 0;\n    requiredRAM: word = 0;\n    largestTrack: word = 0;\n\n    constructor(data: DataView) {\n        this.version = data.getUint8(0);\n        this.diskType = data.getUint8(1);\n        this.writeProtected = data.getUint8(2);\n        this.synchronized = data.getUint8(3);\n        this.cleaned = data.getUint8(4);\n        this.creator = stringFromBytes(data, 5, 37);\n\n        if (this.version > 1) {\n            this.sides = data.getUint8(37);\n            this.bootSector = data.getUint8(38);\n            this.bitTiming = data.getUint8(39);\n            this.compatibleHardware = data.getUint16(40, true);\n            this.requiredRAM = data.getUint16(42, true);\n            this.largestTrack = data.getUint16(44, true);\n        }\n    }\n}\n\nexport class TMapChunk {\n    trackMap: byte[];\n\n    constructor(data: DataView) {\n        this.trackMap = [];\n\n        for (let idx = 0; idx < 160; idx++) {\n            this.trackMap.push(data.getUint8(idx));\n        }\n    }\n}\n\nconst WOZ_TRACK_SIZE = 6656;\nconst WOZ_TRACK_INFO_BITS = 6648;\n\nexport class TrksChunk {\n    rawTracks: Uint8Array[];\n    tracks: Uint8Array[];\n}\n\nexport class TrksChunk1 extends TrksChunk {\n    constructor(data: DataView) {\n        super();\n\n        this.rawTracks = [];\n        this.tracks = [];\n\n        for (let trackNo = 0, idx = 0; idx < data.byteLength; idx += WOZ_TRACK_SIZE, trackNo++) {\n            let track = [];\n            const rawTrack: bit[] = [];\n            const slice = data.buffer.slice(data.byteOffset + idx, data.byteOffset + idx + WOZ_TRACK_SIZE);\n            const trackData = new Uint8Array(slice);\n            const trackInfo = new DataView(slice);\n            const trackBitCount = trackInfo.getUint16(WOZ_TRACK_INFO_BITS, true);\n            for (let jdx = 0; jdx < trackBitCount; jdx++) {\n                const byteIndex = jdx >> 3;\n                const bitIndex = 7 - (jdx & 0x07);\n                rawTrack[jdx] = (trackData[byteIndex] >> bitIndex) & 0x01 ? 1 : 0;\n            }\n\n            track = [];\n            let offset = 0;\n            while (offset < rawTrack.length) {\n                const result = grabNibble(rawTrack, offset);\n                if (!result.nibble) { break; }\n                track.push(result.nibble);\n                offset = result.offset + 1;\n            }\n\n            this.tracks[trackNo] = new Uint8Array(track);\n            this.rawTracks[trackNo] = new Uint8Array(rawTrack);\n        }\n    }\n}\n\nexport interface Trk {\n    startBlock: word\n    blockCount: word\n    bitCount: number\n}\n\nexport class TrksChunk2 extends TrksChunk {\n    trks: Trk[];\n\n    constructor (data: DataView) {\n        super();\n\n        let trackNo;\n        this.trks = [];\n        for (trackNo = 0; trackNo < 160; trackNo++) {\n            const startBlock = data.getUint16(trackNo * 8, true);\n            const blockCount = data.getUint16(trackNo * 8 + 2, true);\n            const bitCount = data.getUint32(trackNo * 8 + 4, true);\n            if (bitCount === 0) { break; }\n            this.trks.push({\n                startBlock: startBlock,\n                blockCount: blockCount,\n                bitCount: bitCount\n            });\n        }\n        this.tracks = [];\n        this.rawTracks = [];\n\n        const bits = data.buffer;\n        for (trackNo = 0; trackNo < this.trks.length; trackNo++) {\n            const trk = this.trks[trackNo];\n\n            let track = [];\n            const rawTrack: bit[] = [];\n            const start = trk.startBlock * 512;\n            const end = start + trk.blockCount * 512;\n            const slice = bits.slice(start, end);\n            const trackData = new Uint8Array(slice);\n            for (let jdx = 0; jdx < trk.bitCount; jdx++) {\n                const byteIndex = jdx >> 3;\n                const bitIndex = 7 - (jdx & 0x07);\n                rawTrack[jdx] = (trackData[byteIndex] >> bitIndex) & 0x01 ? 1 : 0;\n            }\n\n            track = [];\n            let offset = 0;\n            while (offset < rawTrack.length) {\n                const result = grabNibble(rawTrack, offset);\n                if (!result.nibble) { break; }\n                track.push(result.nibble);\n                offset = result.offset + 1;\n            }\n\n            this.tracks[trackNo] = new Uint8Array(track);\n            this.rawTracks[trackNo] = new Uint8Array(rawTrack);\n        }\n    }\n}\n\nexport class MetaChunk  {\n    values: Record<string, string>;\n\n    constructor (data: DataView) {\n        const infoStr = stringFromBytes(data, 0, data.byteLength);\n        const parts = infoStr.split('\\n');\n        this.values = parts.reduce(function(acc: Record<string, string>, part) {\n            const subParts = part.split('\\t');\n            acc[subParts[0]] = subParts[1];\n            return acc;\n        }, {});\n    }\n}\n\ninterface Chunks {\n    [key: string]: any\n    info?: InfoChunk\n    tmap?: TMapChunk\n    trks?: TrksChunk\n    meta?: MetaChunk\n}\n\n/**\n * Returns a `Disk` object from Woz image data.\n * @param options the disk image and options\n * @returns A bitstream disk\n */\nexport default function createDiskFromWoz(options: DiskOptions): WozDisk {\n    const { rawData } = options;\n    if (!rawData) {\n        throw new Error('Requires rawData');\n    }\n    const dv = new DataView(rawData, 0);\n    let dvOffset = 0;\n    let wozVersion;\n    const chunks: Chunks = {};\n\n    function readHeader() {\n        const wozSignature = dv.getUint32(WOZ_HEADER_START + 0, true);\n\n        switch (wozSignature) {\n            case WOZ1_SIGNATURE:\n                wozVersion = 1;\n                break;\n            case WOZ2_SIGNATURE:\n                wozVersion = 2;\n                break;\n            default:\n                return false;\n        }\n\n        if (dv.getUint32(WOZ_HEADER_START + 4, true) !== WOZ_INTEGRITY_CHECK) {\n            return false;\n        }\n\n        return true;\n    }\n\n    function readChunk() {\n        if (dvOffset >= dv.byteLength) {\n            return null;\n        }\n\n        const type = dv.getUint32(dvOffset, true);\n        const size = dv.getUint32(dvOffset + 4, true);\n        const data = new DataView(dv.buffer, dvOffset + 8, size);\n        dvOffset += size + 8;\n\n        return {\n            type: type,\n            size: size,\n            data: data\n        };\n    }\n\n    if (readHeader()) {\n        dvOffset = WOZ_HEADER_SIZE;\n        let chunk = readChunk();\n        while (chunk) {\n            switch (chunk.type) {\n                case 0x4F464E49: // INFO\n                    chunks.info = new InfoChunk(chunk.data);\n                    break;\n                case 0x50414D54: // TMAP\n                    chunks.tmap = new TMapChunk(chunk.data);\n                    break;\n                case 0x534B5254: // TRKS\n                    if (wozVersion === 1) {\n                        chunks.trks = new TrksChunk1(chunk.data);\n                    } else {\n                        chunks.trks = new TrksChunk2(chunk.data);\n                    }\n                    break;\n                case 0x4154454D: // META\n                    chunks.meta = new MetaChunk(chunk.data);\n                    break;\n                case 0x54495257: // WRIT\n                // Ignore\n                    break;\n                default:\n                    debug('Unsupported chunk', toHex(chunk.type, 8));\n            }\n            chunk = readChunk();\n        }\n    } else {\n        debug('Invalid woz header');\n    }\n\n    debug(chunks);\n\n    const { meta, tmap, trks } = chunks;\n\n    const disk: WozDisk = {\n        encoding: ENCODING_BITSTREAM,\n        trackMap: tmap?.trackMap || [],\n        tracks: trks?.tracks || [],\n        rawTracks: trks?.rawTracks || [],\n        readOnly: true, //chunks.info.writeProtected === 1;\n        name: meta?.values['title'] || options.name,\n        side: meta?.values['side_name'] || meta?.values['side'],\n    };\n\n    return disk;\n}\n","import { includes, memory } from '../types';\nimport { base64_decode } from '../base64';\nimport { DiskOptions, FloppyDisk, JSONDisk, NibbleFormat, NIBBLE_FORMATS } from './types';\nimport createDiskFrom2MG from './2mg';\nimport createDiskFromD13 from './d13';\nimport createDiskFromDOS from './do';\nimport createDiskFromProDOS from './po';\nimport createDiskFromWoz from './woz';\nimport createDiskFromNibble from './nib';\n\n/**\n *\n * @param fmt Type of\n * @param options\n * @returns A nibblized disk\n */\nexport function createDisk(fmt: NibbleFormat, options: DiskOptions): FloppyDisk | null {\n    let disk: FloppyDisk | null = null;\n\n    switch (fmt) {\n        case '2mg':\n            disk = createDiskFrom2MG(options);\n            break;\n        case 'd13':\n            disk = createDiskFromD13(options);\n            break;\n        case 'do':\n        case 'dsk':\n            disk = createDiskFromDOS(options);\n            break;\n        case 'nib':\n            disk = createDiskFromNibble(options);\n            break;\n        case 'po':\n            disk = createDiskFromProDOS(options);\n            break;\n        case 'woz':\n            disk = createDiskFromWoz(options);\n            break;\n    }\n\n    return disk;\n}\n\nexport function createDiskFromJsonDisk(disk: JSONDisk): FloppyDisk | null {\n    const fmt = disk.type;\n    const readOnly = disk.readOnly;\n    const name = disk.name;\n    const side = disk.disk;\n\n    if (includes(NIBBLE_FORMATS, fmt)) {\n        let trackData: memory[][];\n        if (disk.encoding == 'base64') {\n            trackData = [];\n            for (let t = 0; t < disk.data.length; t++) {\n                trackData[t] = [];\n                if (disk.type === 'nib') {\n                    trackData[t][0] = base64_decode(disk.data[t]);\n                } else {\n                    for (let s = 0; s < disk.data[t].length; s++) {\n                        trackData[t][s] = base64_decode(disk.data[t][s]);\n                    }\n                }\n            }\n        } else {\n            trackData = disk.data;\n        }\n\n        const volume = disk.volume || 0xfe;\n\n        const options = {\n            volume,\n            readOnly,\n            name,\n            side,\n            data: trackData\n        } as DiskOptions;\n\n        return createDisk(fmt, options);\n    } else {\n        return null;\n    }\n}\n\n","import DOS from './do';\nimport Nibble from './nib';\nimport ProDOS from './po';\nimport { DiskOptions } from './types';\n\nimport { numToString, debug } from '../util';\n\nconst OFFSETS = {\n    CREATOR: 0x04,\n    FLAGS: 0x0A,\n    FORMAT: 0x0C,\n    BLOCKS: 0x14,\n    DATA_OFFSET: 0x18,\n    BYTES: 0x1C,\n};\n\nconst FLAGS = {\n    READ_ONLY:    0x80000000,\n    VOLUME_VALID: 0x00000100,\n    VOLUME_MASK:  0x000000FF\n};\n\nexport function read2MGHeader(rawData: ArrayBuffer) {\n    const prefix = new DataView(rawData);\n    const signature = numToString(prefix.getInt32(0x0, true));\n    if (signature !== '2IMG') {\n        throw new Error('Unrecognized 2mg signature: ' + signature);\n    }\n    const creator = numToString(prefix.getInt32(OFFSETS.CREATOR, true));\n    const format = prefix.getInt32(OFFSETS.FORMAT, true);\n    const bytes = prefix.getInt32(OFFSETS.BYTES, true);\n    const offset = prefix.getInt32(OFFSETS.DATA_OFFSET, true);\n    const flags = prefix.getInt32(OFFSETS.FLAGS, true);\n    const readOnly = (flags & FLAGS.READ_ONLY) !== 0;\n    let volume = 254;\n    if (flags & FLAGS.VOLUME_VALID) {\n        volume = flags & FLAGS.VOLUME_MASK;\n    }\n\n    debug('created by', creator);\n\n    return {\n        bytes,\n        creator,\n        format,\n        offset,\n        readOnly,\n        volume,\n    };\n}\n\n/**\n * Returns a `Disk` object from a 2mg image.\n * @param options the disk image and options\n */\nexport default function createDiskFrom2MG(options: DiskOptions) {\n    let { rawData } = options;\n    let disk;\n\n    if (!rawData) {\n        throw new Error('Requires rawData');\n    }\n\n    const { bytes, format, offset, readOnly, volume } = read2MGHeader(rawData);\n    rawData = rawData.slice(offset, offset + bytes);\n    options = { ...options, rawData, readOnly, volume };\n\n    // Check image format.\n    // Sure, it's really 64 bits. But only 2 are actually used.\n    switch (format) {\n        case 1: // PO\n            disk = ProDOS(options);\n            break;\n        case 2: // NIB\n            disk = Nibble(options);\n            break;\n        case 0: // dsk\n        default:  // Something hinky, assume 'dsk'\n            disk = DOS(options);\n            break;\n    }\n\n    return disk;\n}\n","import { explodeSector13, D13O } from './format_utils';\nimport { NibbleDisk, DiskOptions, ENCODING_NIBBLE } from './types';\n\n/**\n * Returns a `Disk` object from DOS 3.2-ordered image data.\n * @param options the disk image and options\n * @returns A nibblized disk\n */\nexport default function createDiskFromDOS13(options: DiskOptions) {\n    const { data, name, side, rawData, volume, readOnly } = options;\n    const disk: NibbleDisk = {\n        format: 'd13',\n        encoding: ENCODING_NIBBLE,\n        name,\n        side,\n        volume,\n        readOnly,\n        tracks: []\n    };\n\n    if (!data && !rawData) {\n        throw new Error('data or rawData required');\n    }\n\n    /*\n     * DOS 13-sector disks have the physical sectors skewed on the track. The skew\n     * between physical sectors is 10 (A), resulting in the following physical order:\n     *\n     *   0 A 7 4 1 B 8 5 2 C 9 6 3\n     *\n     * Note that because physical sector == logical sector, this works slightly\n     * differently from the DOS and ProDOS nibblizers.\n     */\n\n    for (let t = 0; t < 35; t++) {\n        let track: number[] = [];\n        for (let disk_sector = 0; disk_sector < 13; disk_sector++) {\n            const physical_sector = D13O[disk_sector];\n            let sector: Uint8Array;\n            if (rawData) {\n                const off = (13 * t + physical_sector) * 256;\n                sector = new Uint8Array(rawData.slice(off, off + 256));\n            } else if (data) {\n                sector = data[t][physical_sector];\n            } else {\n                throw new Error('Requires data or rawData');\n            }\n            track = track.concat(\n                explodeSector13(volume, t, physical_sector, sector)\n            );\n        }\n        disk.tracks.push(new Uint8Array(track));\n    }\n\n    return disk;\n}\n","import { debug } from '../js/util';\nimport { jsonDecode } from '../js/formats/format_utils';\nimport {\n    createDisk,\n    createDiskFromJsonDisk,\n} from '../js/formats/create_disk';\nimport {\n    FormatWorkerMessage,\n    Disk,\n    DiskProcessedResponse,\n    DISK_PROCESSED,\n    PROCESS_BINARY,\n    PROCESS_JSON_DISK,\n    PROCESS_JSON,\n} from '../js/formats/types';\n\ndebug('Worker loaded');\n\naddEventListener('message', (message: MessageEvent<FormatWorkerMessage>) => {\n    debug('Worker started', message.type);\n    const data = message.data;\n    const { drive } = data.payload;\n    let disk: Disk | null = null;\n\n    switch (data.type) {\n        case PROCESS_BINARY: {\n            const { fmt, options } = data.payload;\n            disk = createDisk(fmt, options);\n        }\n            break;\n\n        case PROCESS_JSON_DISK: {\n            const { jsonDisk } = data.payload;\n            disk = createDiskFromJsonDisk(jsonDisk);\n        }\n            break;\n\n        case PROCESS_JSON: {\n            const { json } = data.payload;\n            disk = jsonDecode(json);\n        }\n            break;\n    }\n\n    const response: DiskProcessedResponse = {\n        type: DISK_PROCESSED,\n        payload: {\n            drive,\n            disk\n        }\n    };\n\n    self.postMessage(response);\n\n    debug('Worker complete', message.type);\n});\n","/**\n * Extracts the members of a constant array as a type. Used as:\n *\n * @example\n * const SOME_VALUES = ['a', 'b', 1, 2] as const;\n * type SomeValues = MemberOf<typeof SOME_VALUES>; // 'a' | 'b' | 1 | 2\n */\nexport type MemberOf<T extends ReadonlyArray<unknown>> =\n    T extends ReadonlyArray<infer E> ? E : never;\n\n/**\n * Recursively extracts all members of a constant array as a type. Used as:\n *\n * @example\n * const SOME_ARRAYS = [['a'],['b', 2], 3] as const;\n * type SomeArrayValues = DeepMemberOf<typeof SOME_ARRAYS>; // 'a' | 'b' | 2 | 3\n */\nexport type DeepMemberOf<T extends ReadonlyArray<unknown>> =\n    T extends ReadonlyArray<infer E>\n    ? (E extends ReadonlyArray<unknown> ? DeepMemberOf<E> : E)\n    : never;\n\n/**\n * Extracts the declared keys of a type by removing `string` and `number`.\n *\n * Cribbed from the interwebs:\n * https://github.com/microsoft/TypeScript/issues/25987#issuecomment-408339599\n */\nexport type KnownKeys<T> = {\n    [K in keyof T]: string extends K ? never : number extends K ? never : K\n} extends { [_ in keyof T]: infer U } ? U : never;\n\n/**\n * Extracts the declared values of a constant object.\n */\nexport type KnownValues<T> = T extends {\n    [_ in keyof T]: infer U } ? U : never;\n\n/**\n * Replacement for `includes` on constant types that is also a type assertion.\n *\n * @example\n * const SOME_VALUES = [1, 2, 'a'] as const;\n * let n: number = 1;\n * let r = includes(SOME_VALUES, n); // r === true, n is 1 | 2 | 'a'\n * n = 5;\n * r = includes(SOME_VALUES, n); // r === false, n is number\n */\nexport function includes<S extends T, T>(a: ReadonlyArray<S>, v: T): v is S {\n    return (a as ReadonlyArray<T>).includes(v);\n}\n\n/** A bit. */\nexport type bit = 0 | 1;\n\n/** A nibble. */\nexport type nibble =\n    0x0 | 0x1 | 0x2 | 0x3 | 0x4 | 0x5 | 0x6 | 0x7 |\n    0x8 | 0x9 | 0xa | 0xb | 0xc | 0xd | 0xe | 0xf;\n\n/** A byte (0..255). This is not enforced by the compiler. */\nexport type byte = number;\n\n/** A word (0..65535). This is not enforced by the compiler. */\nexport type word = number;\n\n/** A raw region of memory. */\nexport type memory = Uint8Array;\n\n/** A raw region of memory. */\nexport type rom = ReadonlyUint8Array;\n\nexport interface Memory {\n    /** Read a byte. */\n    read(page: byte, offset: byte): byte;\n    /** Write a byte. */\n    write(page: byte, offset: byte, value: byte): void;\n}\n\n/** A mapped region of memory. */\nexport interface MemoryPages extends Memory {\n    /** Start page. */\n    start(): byte;\n    /** End page, inclusive. */\n    end(): byte;\n}\n\n/* An interface card */\nexport interface Card extends Memory, Restorable {\n    /* Reset the card */\n    reset?(): void;\n\n    /* Draw card to canvas */\n    blit?(): ImageData | undefined;\n\n    /* Process period events */\n    tick?(): void;\n\n    /* Read or Write an I/O switch */\n    ioSwitch(off: byte, val?: byte): byte | undefined;\n}\n\nexport type TapeData = Array<[duration: number, high: boolean]>;\n\nexport interface Restorable<T = any> {\n    getState(): T;\n    setState(state: T): void;\n}\n\n// Read-only typed arrays for constants\nexport type TypedArrayMutableProperties = 'copyWithin' | 'fill' | 'reverse' | 'set' | 'sort';\nexport interface ReadonlyUint8Array extends Omit<Uint8Array, TypedArrayMutableProperties> {\n    readonly [n: number]: number\n}\n\n// Readonly RGB color value\nexport type Color = readonly [r: byte, g: byte, b: byte];\n"],"sourceRoot":""}